#include <stdio.h>
#include <stdlib.h>
#include <sdcard/gcsd.h>
#include <malloc.h>
#include <unistd.h>
#include <ogc/lwp_watchdog.h>
#include <fcntl.h>
#include <ogc/system.h>
#include <gccore.h>
#include <string.h>
#include "aram/sidestep.h"
#include "fatfs/ffshim.h"
#include "fatfs/ff.h"
#if !defined(RECOVERY_LOADER)
#include "gfx/kunai_logo.h"
#include "gfx/gfx.h"
#include "spiflash/spiflash.h"
#include "kunaigc/kunaigc.h"
#endif

#define KUNAI_VERSION "1.0"

/*** 2D Video Globals ***/
#if defined(RECOVERY_LOADER)
static void *xfb = NULL;
GXRModeObj *rmode;
#else
GXRModeObj *vmode;		/*** Graphics Mode Object ***/
u32 *xfb[2] = { NULL, NULL };	/*** Framebuffers ***/
int whichfb = 0;		/*** Frame buffer toggle ***/
int screenheight;
int vmode_60hz = 0;
u32 retraceCount;
#endif

u8 *dol = NULL;
#if defined(RECOVERY_LOADER)
char path[32] = "/kunaigc/recovery.dol";
#else
char path[32] = "/kunaigc.dol";
#endif
void dol_alloc(int size)
{
	int mram_size = (SYS_GetArenaHi() - SYS_GetArenaLo());
	kprintf("Memory available: %iB\n", mram_size);

	kprintf("DOL size is %iB\n", size);

	if (size <= 0)
	{
		kprintf("Empty DOL\n");
		return;
	}

	if (size >= (AR_GetSize() - (64 * 1024)))
	{
		kprintf("DOL too big\n");
		return;
	}

	dol = (u8 *) memalign(32, size);

	if (!dol)
	{
		kprintf("Couldn't allocate memory\n");
	}
}

void kunai_disable(void) {
	u32 addr = 0xFFFFFFFF; //disable the KunaiGC by sending only '1' to the Bus
	EXI_Lock(EXI_CHANNEL_0, EXI_DEVICE_1, NULL);
	EXI_Select(EXI_CHANNEL_0, EXI_DEVICE_1, EXI_SPEED8MHZ);
	EXI_Imm(EXI_CHANNEL_0, &addr, 4, EXI_WRITE, NULL);
	EXI_Sync(EXI_CHANNEL_0);
	EXI_Deselect(EXI_CHANNEL_0);
	EXI_Unlock(EXI_CHANNEL_0);
}

int load_fat(const char *slot_name, const DISC_INTERFACE *iface_)
{
	int res = 1;

	kprintf("Trying %s\n", slot_name);

	FATFS fs;
	iface = iface_;
	if (f_mount(&fs, "", 1) != FR_OK)
	{
		kprintf("Couldn't mount %s\n", slot_name);
		res = 0;
		goto end;
	}

	char name[256];
	f_getlabel(slot_name, name, NULL);
	kprintf("Mounted %s as %s\n", name, slot_name);

	kprintf("Reading %s\n", path);
	FIL file;
	if (f_open(&file, path, FA_READ) != FR_OK)
	{
		kprintf("Failed to open file\n");
		res = 0;
		goto unmount;
	}

	size_t size = f_size(&file);
	dol_alloc(size);
	if (!dol)
	{
		res = 0;
		goto unmount;
	}
	UINT _;
	f_read(&file, dol, size, &_);
	f_close(&file);

	unmount:
	kprintf("Unmounting %s\n", slot_name);
	iface->shutdown();
	iface = NULL;

	end:
	return res;
}

unsigned int convert_int(unsigned int in)
{
	unsigned int out;
	char *p_in = (char *) &in;
	char *p_out = (char *) &out;
	p_out[0] = p_in[3];
	p_out[1] = p_in[2];
	p_out[2] = p_in[1];
	p_out[3] = p_in[0];
	return out;
}

#define PC_READY 0x80
#define PC_OK    0x81
#define GC_READY 0x88
#define GC_OK    0x89

int load_usb(char slot)
{
	kprintf("Trying USB Gecko in slot %c\n", slot);

	int channel, res = 1;

	switch (slot)
	{
	case 'B':
		channel = 1;
		break;

	case 'A':
	default:
		channel = 0;
		break;
	}

	if (!usb_isgeckoalive(channel))
	{
		kprintf("Not present\n");
		res = 0;
		goto end;
	}

	usb_flush(channel);

	char data;

	kprintf("Sending ready\n");
	data = GC_READY;
	usb_sendbuffer_safe(channel, &data, 1);

	kprintf("Waiting for ack...\n");
	while ((data != PC_READY) && (data != PC_OK))
		usb_recvbuffer_safe(channel, &data, 1);

	if(data == PC_READY)
	{
		kprintf("Respond with OK\n");
		// Sometimes the PC can fail to receive the byte, this helps
		usleep(100000);
		data = GC_OK;
		usb_sendbuffer_safe(channel, &data, 1);
	}

	kprintf("Getting DOL size\n");
	int size;
	usb_recvbuffer_safe(channel, &size, 4);
	size = convert_int(size);

	dol_alloc(size);
	unsigned char* pointer = dol;

	if(!dol)
	{
		res = 0;
		goto end;
	}

	kprintf("Receiving file...\n");
	while (size > 0xF7D8)
	{
		usb_recvbuffer_safe(channel, (void *) pointer, 0xF7D8);
		size -= 0xF7D8;
		pointer += 0xF7D8;
	}
	if(size)
		usb_recvbuffer_safe(channel, (void *) pointer, size);

	end:
	return res;
}


#if !defined(RECOVERY_LOADER)
#define MIN_INDEX 0
#define MAX_INDEX 3
void draw_menu(void){
	int8_t cursor_idx = 0;
		ClearScreen();

		writeLine(0, 0, 640, 480, COL_HIGHLIGHT);
		drawCircle(320, 240, 50, COL_HIGHLIGHT);

		int x = 50;
		for(uint8_t i = 0; i < 10; i++) {

			drawBitmap(640-250-25*i, i*x , image_data_KunaiGCLogo, 250, 81, getColor(25*i, 13*i, 7*i));
		}

		drawString(50, 300,(unsigned char *) "KunaiGC!", getColor(255,255,255), getColor(255,255,255), 4,4);

	while(1){
		ShowScreen();

		CON_InitEx(vmode, 20, 20, 240, 240);


		kprintf("KunaiGC v%s\n", KUNAI_VERSION);
		kprintf("\tBy\t ManCloud\n"
				"\t\t seewood\n"
				"\t\t derKevin\n\n");
		kprintf("SPIFlash-DeviceID: 0x%X\n", kunai_get_deviceid());
		kprintf("swiss-size: 0x%X\n", kunai_read_32bit(0x30000));

		kprintf("Write test:");

		uint32_t readout = kunai_read_32bit(0x2fffc);
		kprintf("\tbefore: %08X", readout);

		kunai_write_32bit(0xdeadbeef, 0x2fffc);

		uint32_t readout2 = kunai_read_32bit(0x2fffc);
		kprintf("\t after: %08X", readout2);


		kprintf("\n%s Index 0", cursor_idx == 0 ? "*" : "");
		kprintf("\n%s Index 1", cursor_idx == 1 ? "*" : "");
		kprintf("\n%s Index 2", cursor_idx == 2 ? "*" : "");
		kprintf("\n%s Index 3", cursor_idx == 3 ? "*" : "");


		PAD_ScanPads();
		u16 currBtns = PAD_ButtonsHeld(0);

		while(currBtns == PAD_ButtonsHeld(0)) {
			PAD_ScanPads();
			VIDEO_WaitVSync();
		}

		if (PAD_ButtonsHeld(0) & PAD_BUTTON_DOWN){
			while(PAD_ButtonsHeld(0) & PAD_BUTTON_DOWN) PAD_ScanPads();
			cursor_idx++;
			cursor_idx = MIN(cursor_idx, MAX_INDEX);
		}

		if (PAD_ButtonsHeld(0) & PAD_BUTTON_UP){
			while(PAD_ButtonsHeld(0) & PAD_BUTTON_UP) PAD_ScanPads();
			cursor_idx--;
			cursor_idx = MAX(cursor_idx, MIN_INDEX);
		}


	}
}
#endif

#if !defined(RECOVERY_LOADER)
static void updatePAD(u32 retrace)
{
	retraceCount = retrace;
	PAD_ScanPads();
#ifdef HW_RVL
	WPAD_ScanPads();
#endif
}
#endif
/****************************************************************************
 * video_initialise Video
 *
 * Before doing anything in libogc, it's recommended to configure a video
 * output.
 ****************************************************************************/
static void video_initialise (void)
{
#if defined(RECOVERY_LOADER)
	VIDEO_Init();

		rmode = VIDEO_GetPreferredMode(NULL);

		xfb = MEM_K0_TO_K1(SYS_AllocateFramebuffer(rmode));

		VIDEO_Configure(rmode);

		VIDEO_SetNextFramebuffer(xfb);

		VIDEO_SetBlack(FALSE);
		VIDEO_Flush();
		VIDEO_WaitVSync();
		if(rmode->viTVMode&VI_NON_INTERLACE) VIDEO_WaitVSync();
#else
	VIDEO_Init ();		/*** ALWAYS CALL FIRST IN ANY LIBOGC PROJECT!
				     Not only does it initialise the video
				     subsystem, but also sets up the ogc os
	 ***/

	PAD_Init ();			/*** video_initialise pads for input ***/
#ifdef HW_RVL
	WPAD_Init ();
#endif

	// get default video mode
	vmode = VIDEO_GetPreferredMode(NULL);

	switch (vmode->viTVMode >> 2)
	{
	case VI_PAL:
		// 576 lines (PAL 50Hz)
		// display should be centered vertically (borders)
		//Make all video modes the same size so menus doesn't screw up
		vmode = &TVPal576IntDfScale;
		vmode->xfbHeight = 480;
		vmode->viYOrigin = (VI_MAX_HEIGHT_PAL - 480)/2;
		vmode->viHeight = 480;

		vmode_60hz = 0;
		break;

	case VI_NTSC:
		// 480 lines (NTSC 60hz)
		vmode_60hz = 1;
		break;

	default:
		// 480 lines (PAL 60Hz)
		vmode_60hz = 1;
		break;
	}
#ifdef HW_DOL
    /* we have component cables, but the preferred mode is interlaced
     * why don't we switch into progressive?
     * (user may not have progressive compatible display but component input)
     * on the Wii, the user can do this themselves on their Wii Settings */
    if(VIDEO_HaveComponentCable())
        vmode = &TVNtsc480Prog;
#endif

	// configure VI
	VIDEO_Configure (vmode);

	// always 480 lines /*** Update screen height for font engine ***/
	screenheight = vmode->xfbHeight;

	/*** Now configure the framebuffer.
	     Really a framebuffer is just a chunk of memory
	     to hold the display line by line.
	 ***/
	// Allocate the video buffers
	xfb[0] = (u32 *) MEM_K0_TO_K1 (SYS_AllocateFramebuffer (vmode));
	/*** I prefer also to have a second buffer for double-buffering.
	     This is not needed for the console demo.
	 ***/
	xfb[1] = (u32 *) MEM_K0_TO_K1 (SYS_AllocateFramebuffer (vmode));

	/*** Clear framebuffer to black ***/
	VIDEO_ClearFrameBuffer (vmode, xfb[0], COLOR_BLACK);
	VIDEO_ClearFrameBuffer (vmode, xfb[1], COLOR_BLACK);

	/*** Set the framebuffer to be displayed at next VBlank ***/
	VIDEO_SetNextFramebuffer (xfb[0]);

	/*** Get the PAD status updated by libogc ***/
	VIDEO_SetPostRetraceCallback (updatePAD);
	VIDEO_SetBlack (0);

	/*** Update the video for next vblank ***/
	VIDEO_Flush ();

	VIDEO_WaitVSync ();		/*** Wait for VBL ***/
	if (vmode->viTVMode & VI_NON_INTERLACE)
		VIDEO_WaitVSync ();

	ShowScreen();
#endif
}

int main()
{
	// If this is set to 1 force the
	u8 forceIPL = 0;

	video_initialise();
	//    FT_Init();

	*(volatile unsigned long *) 0xCC00643C = 0x00000000; // Enable 27MHz EXI

	// Note: fuck libogc and dkppc
	u32 t = ticks_to_secs(SYS_Time());
	settime(secs_to_ticks(t));

#if defined(RECOVERY_LOADER)
	CON_Init(xfb, 20, 20, rmode->fbWidth, rmode->xfbHeight, rmode->fbWidth * 2);
	kprintf("\n\nKunaiRecovery - based on IPLboot\n");

	// SD Gecko Slot A, Slot B
	if (load_fat("sda", &__io_gcsda))
	{
		goto load;
	}

	// SD2SP2
	if (load_fat("sd2", &__io_gcsd2))
	{
		goto load;
	}
load:
#else
	CON_Init(xfb[whichfb], 20, 20, vmode->fbWidth, vmode->xfbHeight, vmode->fbWidth * 2);
	kprintf("\n\nKunaiLoader - based on IPLboot\n");
	// Disable Qoob
	u32 val = 6 << 24;
	u32 addr = 0xC0000000;
	EXI_Lock(EXI_CHANNEL_0, EXI_DEVICE_1, NULL);
	EXI_Select(EXI_CHANNEL_0, EXI_DEVICE_1, EXI_SPEED8MHZ);
	EXI_Imm(EXI_CHANNEL_0, &addr, 4, EXI_WRITE, NULL);
	EXI_Sync(EXI_CHANNEL_0);
	EXI_Imm(EXI_CHANNEL_0, &val, 4, EXI_WRITE, NULL);
	EXI_Sync(EXI_CHANNEL_0);
	EXI_Deselect(EXI_CHANNEL_0);
	EXI_Unlock(EXI_CHANNEL_0);

	// Set the timebase properly for games

	PAD_ScanPads();

	if (PAD_ButtonsDown(0) & PAD_BUTTON_Y)
	{
		strcpy(path, "/y.dol");
	}

	if (PAD_ButtonsDown(0) & PAD_BUTTON_X)
	{
		strcpy(path, "/x.dol");
	}

	if (PAD_ButtonsDown(0) & PAD_BUTTON_A)
	{
		goto end;
	}

	if (PAD_ButtonsDown(0) & PAD_BUTTON_START)
	{
		draw_menu();

	}

	// SD Gecko Slot A, Slot B
	if (load_fat("sda", &__io_gcsda))
	{
		goto load;
	}
	if (load_fat("sdb", &__io_gcsdb))
	{
		goto load;
	}

	// USB Gecko Slot A, Slot B
	if (load_usb('B'))
	{
		goto load;
	}

	if (load_usb('A'))
	{
		goto load;
	}

	// SD2SP2
	if (load_fat("sd2", &__io_gcsd2))
	{
		goto load;
	}

	load:
	while (PAD_ButtonsHeld(PAD_CHAN0) & PAD_BUTTON_DOWN)
	{
		VIDEO_WaitVSync();
		PAD_ScanPads();
	}
#endif

	if (dol && !forceIPL)
	{
		DOLtoARAM(dol, 0, NULL);
	}

	end:
	// If we reach here, all attempts to load a DOL failed
	// Since we've disabled the Qoob, we wil reboot to the Nintendo IPL
	kunai_disable();
	return 0;

}
